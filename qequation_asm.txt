; preamble

push 1000 ; RAM starting point
pop rax   ; set RAM counter

jmp main  ; program start

main:
	push 0
	pop [rax + 0] ; a assign
	push 0
	pop [rax + 1] ; b assign
	push 0
	pop [rax + 2] ; c assign
	in
	pop [rax + 0] ; input var a

	in
	pop [rax + 1] ; input var b

	in
	pop [rax + 2] ; input var c

	push 0
	pop [rax + 3] ; x assign
	push [rax + 0] ; a

	push 0
	jne L0
	push [rax + 1] ; b

	push [rax + 2] ; c


	push rax ; stack frame prologue
	push 0
	add
	pop rax


	call solveLinearEquation


	push rax ; stack frame epilogue
	push 0
	sub
	pop rax

	pop [rax + 3] ; x assign
L0:   ; end if
	push [rax + 0] ; a

	push 0
	je L1
	push [rax + 0] ; a

	push [rax + 1] ; b

	push [rax + 2] ; c


	push rax ; stack frame prologue
	push 0
	add
	pop rax


	call solveQuadraticEquation


	push rax ; stack frame epilogue
	push 0
	sub
	pop rax

	pop [rax + 3] ; x assign
L1:   ; end if

	hlt

solveLinearEquation:
	pop [rax + 0] ; a

	pop [rax + 1] ; b

	pop [rax + 2] ; c

	push [rax + 1] ; b

	push 0
	jne L2
	push [rax + 2] ; c

	push 0
	je L2
	push 1
	out
L2:   ; end if
	push [rax + 2] ; c

	push 0
	jne L3
	push 1
	out
	push 0
	out
L3:   ; end if
L4:   ; end if
	push [rax + 1] ; b

	push 0
	je L5
	push [rax + 2] ; c

	push [rax + 1] ; b

	DIV
	SUB
	pop [rax + 0] ; x assign
	push [rax + 0] ; x

	out
L5:   ; end if
	push 1
	ret


solveQuadraticEquation:
	pop [rax + 0] ; a

	pop [rax + 1] ; b

	pop [rax + 2] ; c

	push [rax + 1] ; b

	push 2
	POW
	push 4
	push [rax + 0] ; a

	MUL
	push [rax + 2] ; c

	MUL
	SUB
	pop [rax + 3] ; d assign
	push [rax + 3] ; d

	push 0
	jae L6
	push 0
	out
L6:   ; end if
	push [rax + 3] ; d

	push 0
	jne L7
	push [rax + 1] ; b

	push 2
	push [rax + 0] ; a

	MUL
	DIV
	SUB
	pop [rax + 0] ; x assign
	push [rax + 0] ; x

	out
L7:   ; end if
	push [rax + 3] ; d

	push 0
	jbe L8
	push [rax + 1] ; b

	SUB
	push [rax + 3] ; d

	SQRT
	ADD
	push 2
	push [rax + 0] ; a

	MUL
	DIV
	pop [rax + 0] ; x assign
	push [rax + 1] ; b

	SUB
	push [rax + 3] ; d

	SQRT
	SUB
	push 2
	push [rax + 0] ; a

	MUL
	DIV
	pop [rax + 1] ; y assign
	push 2
	out
	push [rax + 0] ; x

	out
	push [rax + 1] ; y

	out
L8:   ; end if
	push 1
	ret


